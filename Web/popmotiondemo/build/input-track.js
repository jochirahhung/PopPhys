window.__NEXT_REGISTER_PAGE('/learn/input-tracking', function() {
    var comp = module.exports=webpackJsonp([11],{193:function(t,e,n){"use strict";function o(t){return t&&t.__esModule?t:{default:t}}var a=n(0),r=function(t){return t&&t.__esModule?t:{default:t}}(a);e.__esModule=!0;var i=n(3),s=o(i),c=n(2),l=o(c),p=n(0),u=n(5),d=o(u),m=n(1),h=n(7),f=n(6),g=o(f),v=n(4),k=o(v),y=n(8),w=o(y),x=function(t){return""!==t},T=(0,d.default)({createElement:p.createElement,a:m.A,h1:m.H1,h2:m.H2,h3:m.H3,h4:m.H4,p:m.P,code:m.Code,li:m.Li,ul:m.Ul,hr:m.Hr,img:h.Img,blockquote:m.Blockquote,components:{Example:k.default,CodePen:w.default}}),b=T("\n# Pointers and dragging\n\nUser input tracking can be used for a ton of different purposes. Drag & drop, scrolling galleries and performantly measuring touch scroll speed are some of the first to come to mind.\n\nIn this quick tutorial, we'll look at how to track mouse and touch movement with the `pointer` action.\n\nThen, we'll track the pointer's offset and use that to drag a DOM element around.\n\n## The `pointer` action\n\nThe `pointer` action provides a generic interface for interacting with mouse and touch input. When provided with a `MouseEvent` or `TouchEvent`, it will output the `clientX` `clientY` positions to the provided `onUpdate` function.\n\nFirst, import the action:\n\n```javascript\nimport { pointer } from 'popmotion';\n```\n\nWe need to provide either a `MouseEvent` or `TouchEvent` to `pointer` to begin tracking. This is usually taken from a `mousedown`/`touchstart` event, as this is when a user is signalling an intent to interact. But it can be just as easily taken from `mousemove`/`touchmove`.\n\n```javascript\nlet pointerTracker;\n\n// Start tracking pointer movement\ndocument.addEventListener('mousedown', (event) => {\n  pointerTracker = pointer(event, {\n    onUpdate: ({ x, y }) => console.log(x, y)\n  }).start();\n});\n\n// Stop tracking pointer movement\ndocument.addEventListener('mouseup', () => {\n  if (pointerTracker) pointerTracker.stop();\n});\n```\n\n## Dragging\n\nIt's that simple to track and output pointer movement, but the majority of the time we're using that data to drag or scroll.\n\n`pointer` provides \"absolute\" positioning. That is, if you start tracking at `x: 50, y: 100`, you can't apply those values directly to an element that might technically be at the location on screen and yet has a `x,y` transform of `0,0`.\n\nTo get \"relative\" positioning we have another action, `trackOffset`. This tracks the **offset** of any provided action, whether it's `tween`, `physics` or in our case, `pointer`.\n\n```javascript\nimport { pointer, trackOffset } from 'popmotion';\n```\n\nHere's how we'd track the offset of just the `x` axis:\n\n```javascript\ndocument.addEventListener('mousedown', (e) => {\n  const pointerTracker = pointer(e).start();\n\n  // Note: We're providing just the `x` property of `pointerTracker`, as\n  // `pointer` returns a composite action of `x` and `y` actions.\n  trackOffset(pointerTracker.x, {\n    onUpdate: (x) => console.log(x)\n  }).start();\n});\n```\n\nThis code will output `0` when the mouse starts moving, and apply any further mouse movement to that `0`. We can also supply a different `from` value to start from a number other than `0`:\n\n```javascript\ntrackOffset(pointerTracker.x, {\n  from: 50,\n  onUpdate: (x) => console.log(x)\n}).start();\n```\n\nWhich means, if we have a DOM element, we can provide its current `x` location to the `from` property and we'll start applying pointer movement to that, resulting in a drag. Take a look at this live, editable example:\n\n(To activate this demo, press \"Start\" and then start dragging the ball around)\n\n```marksy\n<Example template=\"Ball\">{`\nconst ball = document.querySelector('.ball');\nconst ballRenderer = css(ball);\nlet pointerTracker;\nlet xOffset;\n\n// Start tracking\nfunction startTracking(e) {\n  pointerTracker = pointer(e).start();\n  xOffset = trackOffset(pointerTracker.x, {\n    from: ballRenderer.get('x'),\n    onUpdate: (x) => ballRenderer.set('x', x)\n  }).start();\n}\n\n// Finish tracking\nfunction stopTracking() {\n  if (pointerTracker) pointerTracker.stop();\n  if (xOffset) xOffset.stop();\n}\n\nball.addEventListener('mousedown', startTracking);\nball.addEventListener('touchstart', startTracking);\ndocument.addEventListener('mouseup', stopTracking);\ndocument.addEventListener('touchend', stopTracking);\n`}</Example>\n```\n\nNow we've got dragging working, in the [next topic](/learn/velocity-and-physics) we'll look at getting the velocity of a user's pointer movements and providing that to a `physics` action. With that, we can produce a variety of momentum-based scrolling or spring-based \"snap to\" animations that feel natural, physical and engaging compared to traditional tweens.\n"),E=function(t){var e=t.section;return r.default.createElement(g.default,{id:"input-tracking",section:e,category:"basics",title:"Pointers and dragging",description:"Learn to track mouse and touch movement and use that to drag DOM elements.",published:""},b.tree)};E.getInitialProps=function(){var t=(0,l.default)(s.default.mark(function t(e){var n,o,a=e.pathname;e.req;return s.default.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=a.split("/").filter(x),o=n[0],t.abrupt("return",{section:o});case 3:case"end":return t.stop()}},t,void 0)}));return function(e){return t.apply(this,arguments)}}(),e.default=E},395:function(t,e,n){t.exports=n(193)}},[395]);
    return { page: comp.default }
  })